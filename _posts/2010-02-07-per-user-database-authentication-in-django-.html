--- 
layout: post
title: "Per-User Database Authentication in Django "
published: true
---
A colleague was recently talking about the need for a data entry interface to a database, and I glibly said &quot;let me see how easy it is to put a Django-admin front-end on it!&quot;.  It turned out to be some-what less easy than expected; this post documents my solution to one of the less-easy aspects of it (there were others, but those were mostly to do with concerns of scale and better-documented issues surrounding legacy databases).  It is still quite an ugly solution, and please see the end for some fairly important caveats.  I&#39;m documenting it here though because I did find other people with the same problem, but have yet to come across a solution.<p /> The problem is this: Django assumes that in general it will control the database, including creating the schema and implementing any logic.  This particular database made the opposite assumption; front-ends were merely conduits, and any verification etc would be handled internally.  In this case that wasn&#39;t much more complicated than updating fields such as &quot;added by&quot; via triggers, but the principles apply across a range of scenarios.  <a href="http://www.b-list.org/weblog/2006/nov/02/django-tips-auto-populated-fields/">Here&#39;s a random example</a> of the Django way.<p /> So, to play nicely with the database we&#39;d ideally like each connection to be made using the credentials of the user using the application, and Django really isn&#39;t built for this.  One reason is that <span style="font-family: courier new,monospace;">django.db.connection</span> is a module-constant initialised with the database settings from <span style="font-family: courier new,monospace;">settings.py</span>, but if you are willing to swallow your pride we can also exploit this to our advantage.<p /> The first step is write an authentication back-end so the user will be authenticated using their database credentials:<br /><script src="https://gist.github.com/276655.js?file=auth.py"></script><br /> (I also changed the base admin template so it doesn&#39;t offer the &quot;change password&quot; option).  This is fairly standard; I&#39;m using Oracle, but obviously any database can be made to work similarly.  Note that we still need the default database account in <span style="font-family: courier new,monospace;">settings.py</span>, and this will be used to create the new user in the <span style="font-family: courier new,monospace;">django.contrib.auth</span> tables for example.<p /> Step two is, err, to save the password in the session (I told you I felt dirty), so we can create a database connection using it each request.  This needs to happen in the login method, where you have access to both the session and the username/password.<p /> Step three is to convert <span style="font-family: courier new,monospace;">django.db.connection</span> to use these credentials instead of the defaults from <span style="font-family: courier new,monospace;">settings.py</span>; I did this using a custom middleware:<br /> <script src="https://gist.github.com/276655.js?file=middleware.py"></script><p />At this point we&#39;re almost done, but a problem still remains: I&#39;m using Oracle where each user has their own private schema, and the application is expecting to find a bunch of tables which don&#39;t exist in the user&#39;s schema.  We could get around this using synonyms for example, but instead I used a signal that is fired each time a connection is created (there seems to be precious little information or examples about this signal either) in order to change the schema the connection is using:<br /> <script src="https://gist.github.com/276655.js?file=models.py"></script><br />This needs to be executed each time, so I put it in <span style="font-family: courier new,monospace;">models.py</span>.<p /> So, all in all, a fairly minimal solution, but...<p /><i><b>Here be Dragons!</b></i>  As I mentioned, there are some pretty important caveats to be aware of if you ever use this (I accept no responsibility for any breakage, break-ins, yadda yadda yadda).  Most importantly, you are storing the user&#39;s password in plain-text for the duration of the session.  For our purposes this is fine; it&#39;s an internal application where security isn&#39;t exactly critical.  Your mileage may vary, significantly.<p /> Secondly and perhaps more importantly, the various other Django applications still need access to their tables, but now you are connecting as a different user, so each user using the application will also need permission on these tables.  This is the bit that turns my stomach the most!<p /> Lastly, there may well be consequences, race conditions, etc in manipulating <span style="font-family: courier new,monospace;">django.db.connection</span> that I have not come across yet.<p />Please let me know if there is an easier/cleaner way!  <i>(I still feel dirty)</i>
